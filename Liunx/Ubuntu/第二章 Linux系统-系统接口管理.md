# 	第二章 Linux系统-系统接口管理

​	操作系统接口时架构在硬件上的第一层软件，时计算机底层硬件和用户之间的接口，利用操作系统才能使用应用程序（或用户）对系统硬件的访问。任何操作系统都会想上层提供接口，操作系统接口是方便用户使用计算机系统的关键。操作系统的接口分为用户接口和程序接口两大类，用户接口又包括命令接口和图形接口。

- **命令接口：**操作系统提供的一组连接命令接口，用户通过输入相关命令，获得操作系统的服务，控制用户程序的执行。
- **图形接口：**通过突变、窗口、菜单等形成直观易懂、使用方便的计算机操作环境，以鼠标驱动的方式使用系统的用户界面。
- **程序接口：**有一组系统调用命令组成的，这些命令可供应用程序使用，使程序员访问系统资源，系统调用是操作系统提供给应用程序访问系统资源的唯一接口，每个系统调用都是一个能完成功能的子程序。



## 1.Shell命令接口

​	Shell是Linux操作系统的最外层，也称为外壳。一方面它可以作为操作系统的命令接口，以交互的方式解释和执行用户输入的命令，或自动解释和执行预先设定好的一连串命令，实现用户与计算机的交互。另一方面，Shell也能用作解释性的编程语言。**Linux下的Shell命令接口由一组命令和命令解释程序Shell组成**。

​	Shell来源于UNIX系统，在UNIX诞生之初，只配有一个命令解释器，它用于解释和执行用户的命令。1979年，贝尔实验室的Bourne开发出第一个Shell程序---B Shell（bsh），20世纪80年代，Bill Joy开发了C Shell（csh）。在此后很长一段时间，人们用B Shell来编程，C Shell来实现交互。后来贝尔实验室的大卫.科恩开发了K Shell，它融合了B Shell和C Shell的特点，广受用户的欢迎。

​	还有一种Shell版本尤为著名，就是Bourne Again Shell（bash）。bash是GNU计划的一部分，用于替代B Shell，它用于基于GNU的Linux系统。常见的Shell版本有：

- bsh：最经典的Shell，每种Linux、UNIX都可用；

- csh：其语法与C语言相似，交互性更好；

- ksh：结合了csh和bsh的优点；

- tcsh：csh的扩展；

- bash：bsh的扩展，结合了csh和ksh的优点；

- zsh：结合了bash、tcsh的许多功能。

  大多数的Linux系统默认使用bash。Linux常用的shell可以通过/etc/shells文件查看：

```shell
cat /etc/shells
```

<img src="https://gitee.com/zou_tangrui/note-pic/raw/master/img/202308151431063.png" style="zoom:50%;" />



## 2.GNOME桌面环境

​	1999年，墨西哥程序员Miguel开发了Linux下的桌面GNOME1.0。GNOME是基于GPL的完全开放的软件，可以让用户容易地使用和配置计算机。GNOME遵照GPL许可发行，得到Red Hat等公司的大力支持，成为了众多Linux发行版默认安装的桌面环境，GNOME即GNU网络对象模型环境（GNU Network Object Model Environment）。

​	GNOME的官方网站为：www.gnome.org。Ubuntu20使用了GNOME3.38版本作为默认的桌面环境。在GNOME模式下，桌面主要由3部分组成：状态栏、dock面板（任务栏）、桌面区。

![image-20230815144431862](https://gitee.com/zou_tangrui/note-pic/raw/master/img/202308151444595.png)



**GNOME下的快捷键：**

| 快捷键              | 作用                     |
| ------------------- | ------------------------ |
| Super（Windows）    | 打开活动搜索             |
| Ctrl+Alt+T          | 打开一个或多个命令行窗口 |
| Super+L(Ctrl+Atl+L) | 锁屏                     |
| Super+D(Ctrl+Alt+D) | 最小化所有程序，显示桌面 |
| Super+A             | 显示应用菜单             |
| Super+Tab(Alt+Tab)  | 在运行间的应用程序间切换 |
| Super+方向键        | 移动窗口位置             |
| Super+M(Super+V)    | 切换到状态栏，并显示日期 |
| Super+空格          | 切换输入法               |
| Ctrl+Q（Ctrl+W）    | 关闭应用程序窗口         |
| Ctrl+Alt+方向键     | 切换工作区               |
| Ctrl+Alt+DEL        | 注销系统                 |





## 3.登录、注销、关机和重启



### 3.1.登录系统

​	Linux是一个多用户、多任务的操作系统，本机用户和任何访问该系统的合法用户都拥有一个账号，通过用户名+密码的方式进行登录验证，验证通过后就能进入系统。

​	Linux的超级用户为root（根用户），相当于Windows中的Administrator，对系统有完全的控制权。Ubuntu默认以普通用户登录，Linux采用软件的方式，在一个物理控制台上虚拟了多达12各控制台，包括6个字符控制台和6个图形控制台，控制台之间可以通过`Ctrl+Alt+Fn`组合键来切换，其中`F1-F6`为字符控制台，`F7`对应图形控制台（默认启动显示器显示F7）。

​	Linux除了**控制台登录外**，还可以**远程登录**，常用的远程登录工具有MobXterm、XShell等。



### 3.2.注销系统

​	除了上述的快捷键`Ctrl+ALT+DEL`来注销用户之外，我们还可以通过面板的向下箭头来注销用户或关机。

<img src="https://gitee.com/zou_tangrui/note-pic/raw/master/img/202308151524181.png" alt="image-20230815152432086" style="zoom:50%;" />



### 3.3.关机和重启

​	关于关机和重启，除了在图形控制台控制之外，我们一般采用命令的方式来操作这一功能。

```shell
poweroff							# 关机
reboot								# 重启
halt								# 挂起
```

​	除了上述命令外，还有其他的命令用来关机或重启，比如"shutdown"，而且它还有很多拓展功能：

```shell
shutdown -h now					// 立即关闭系统
shutdown -r now					// 立即重启系统
shutdown -h +5					// 	5分钟后关机
shutdown -r +10 'The system will be rebooted'		// 10分钟后重启，同时通知其他用户
```

​	对于延时关机或重启操作，必要时可执行“shutdown -c”命令或按下“Ctrl+C‘取消：

```shell
shutdown -c					// 取消延时关机或重启
```



## 4.系统调用

​	操作系统作为系统软件，它的任务是**为用户的应用程序提供良好的运行环境**。因此，操作系统内核提供了一些列内核函数，通过一组称为系统调用的**接口**提供给用户使用。系统调用的作用是把应用程序的请求传递给系统内核，然后调用相应的内核函数完成所需的处理，最终将处理的结果返回给用户的应用程序。所以说，系统调用是应用程序和系统内核之间的接口。

​	系统调用在系统中的主要作用如下：

- **控制硬件**。如把用户程序的运行结果写入文件，可以利用`write`系统调用来实现。由于文件所在的介质必然是磁盘等硬件设备，所以该系统调用就是对硬件实施的控制。
- **设置系统状态或读取内核数据**。如系统时钟就属于内核数据，要想在用户程序中显示系统时钟，就必须通过读取内核数据来实现，这通过`time`系统调用来处理。
- **进程管理**。如在应用程序中要创建子进程，就需要利用`fork`系统调用来实现。



​	在Linux中常用的系统调用按照功能可分为进程控制、文件系统控制、存储管理、网络管理、socket控制、用户管理和进程管理8类。

​	常用的进程控制类系统调用如下：

| 系统调用 | 功能                 | 系统调用    | 功能               |
| -------- | -------------------- | ----------- | ------------------ |
| fork     | 创建子进程           | getpriority | 获取调度优先级     |
| clone    | 按指定条件创建子进程 | setpriority | 设置调度优先级     |
| execve   | 运行可执行文件       | pause       | 挂起进程，等待信号 |
| exit     | 终止进程             | wait        | 等待子进程终止     |
| getpid   | 获取进程标识号       |             |                    |

​	常用的文件系统控制类系统调用如下：

| 系统调用 | 功能             | 系统调用 | 功能                   |
| -------- | ---------------- | -------- | ---------------------- |
| open     | 打开文件         | mkdir    | 创建目录               |
| create   | 创建新文件       | symlink  | 创建符号链接           |
| read     | 读文件           | mount    | 安装文件系统           |
| write    | 写文件           | umount   | 卸载文件系统           |
| truncate | 截断文件         | ustat    | 获取文件系统信息       |
| chdir    | 改变当前工作目录 | utime    | 改变文件的访问修改时间 |
| stat     | 获取文件状态信息 |          |                        |

​	常用的系统控制类系统调用如下：

| 系统调用 | 功能                                       | 系统调用  | 功能                 |
| -------- | ------------------------------------------ | --------- | -------------------- |
| _sysctl  | 读写系统参数                               | getrusage | 获取系统资源使用情况 |
| uselib   | 选择要使用的二进制函数库                   | reboot    | 重新启动             |
| swapon   | 打开交换文件和设备                         | sysinfo   | 获取系统信息         |
| alarm    | 设置进程闹钟                               | stime     | 设置系统日期和时间   |
| time     | 获取系统时间                               | times     | 获取系统运行时间     |
| uname    | 获取当前UNIX系统的名称、版本、和主机等信息 |           |                      |

​	常用的存储管理类系统调用如下：

| 系统调用   | 功能                     | 系统调用    | 功能                       |
| ---------- | ------------------------ | ----------- | -------------------------- |
| mlock      | 内存页面加锁             | mremap      | 重新映射虚拟内存地址       |
| munlock    | 内存页面解锁             | msync       | 将映射内存中的数据写回磁盘 |
| mlockall   | 调用进程所有内存页面加锁 | mprotect    | 设置内存映像保护           |
| munlockall | 调用进程所有内存页面解锁 | getpagesize | 获取页面大小               |
| mmap       | 映射虚拟内存页           | sync        | 将内存缓冲区数据写回硬盘   |
| munmap     | 接触内存页映射           | cacheflush  | 将指定缓冲区的内容写回磁盘 |

​	常用的网络管理类系统调用如下：

| 系统调用      | 功能           | 系统调用    | 功能           |
| ------------- | -------------- | ----------- | -------------- |
| getdomainname | 获取域名       | sethostid   | 设置主机标识号 |
| setdomainname | 设置域名       | gethostname | 获取主机名称   |
| gethostid     | 获取主机标识号 | serhostname | 设置主机名称   |

​	常用的socket控制类系统调用如下：

| 系统调用   | 功能               | 系统调用    | 功能                  |
| ---------- | ------------------ | ----------- | --------------------- |
| socketcall | socket系统调用     | listen      | 监听socket端口        |
| socket     | 建立socket         | select      | 对多路同步I/O进行轮询 |
| bind       | 绑定socket到端口   | shutdown    | 关闭socket上的连接    |
| connect    | 连接远程主机       | getsockname | 获取本地socket名字    |
| accept     | 响应socket连接请求 | getsockopt  | 获取端口参数          |
| send       | 通过socket发送信息 | setsockopt  | 设置端口参数          |
| recv       | 通过socket接收信息 |             |                       |

​	常用的用户管理类系统调用如下：

| 系统调用  | 功能                                   | 系统调用  | 功能                                   |
| --------- | -------------------------------------- | --------- | -------------------------------------- |
| getuid    | 获取用户标识号                         | setuid    | 设置用户标识号                         |
| getgid    | 获取组标识号                           | setgid    | 获取组标识号                           |
| setregid  | 分别设置真实、有效的组标识号           | setreuid  | 分别设置真实、有效的用户标识号         |
| getresgid | 分别获取真实、有效的和保存过的组标识号 | setresgid | 分别设置真实、有效和保存过的组标识号   |
| getresuid | 分别获取真实、有效和保存过的用户标识号 | setresuid | 分别设置真实、有效和保存过的用户标识号 |

​	常用的进程通信类系统调用如下：

| 系统调用   | 功能                       | 系统调用 | 功能         |
| ---------- | -------------------------- | -------- | ------------ |
| sigaction  | 设置对指定信号的处理方法   | pipe     | 创建管道     |
| sigpending | 为指定的被阻塞信号设置队列 | semctl   | 信号量控制   |
| sigsuspend | 挂起进程，等待特定信号     | semop    | 信号量操作   |
| kill       | 向进程或进程组发信号       | shmctl   | 控制共享内存 |
| msgctl     | 消息控制                   | shmget   | 获取共享内存 |
| msgget     | 获取消息队列               | shmat    | 连接共享内存 |
| msgsnd     | 发消息                     | shmdt    | 拆卸共享内存 |
| msgrcv     | 收消息                     |          |              |

​	

​	**示例1：**获取当前进程的标识号，通过系统调用getpid来实现，我们在当前目录下创建`getpid.c`文件，文件内容如下：

```shell
# include <syscall.h>
# include <unistd.h>
# include <stdio.h>
# include <sys/types.h>

main() {
	long i;
	i = getpid();
	printf("getpid()=%ld\n",i);

}
```



​	然后保存后，用命令`gcc getpid.c`编译文件，如果没有`gcc`命令，可用`sudo apt install gcc`命令来下载，最后运行该文件`./a.out`。

![](https://gitee.com/zou_tangrui/note-pic/raw/master/img/202308160930041.png)

​	

